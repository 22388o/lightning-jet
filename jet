#!/usr/bin/env node

const cap = require('caporal');
const importLazy = require('import-lazy')(require);
const {version} = importLazy('./package');

const lndClient = require('./api/connect');
const {listActiveRebalancesFormattedSync} = require('./api/utils');
const {rebalanceHistoryFormattedSync} = require('./api/utils');
const {pendingHtlcsFormattedSync} = require('./api/utils');
const {listForcedClosingFormattedSync} = require('./api/utils');
const {listPeersFormattedSync} = require('./api/utils');
const {withCommas} = require('./lnd-api/utils');
const {listFeesSync} = require('./lnd-api/utils');
const {listPeersSync} = require('./lnd-api/utils');
const {updateChannelSync} = require('./lnd-api/update-channel');
const {listChannels} = require('./api/list-channels');
const {htlcHistoryFormatted} = require('./api/htlc-history');
const {htlcAnalyzer} = require('./api/htlc-analyzer');
const {classifyPeersSync} = require('./lnd-api/utils');

const {execSync} = require('child_process');
const {statSync} = require('fs');
const date = require('date-and-time');

const {getServiceNames} = require('./service/utils');
const {stopService} = require('./service/utils');
const {startService} = require('./service/utils');
const {restartService} = require('./service/utils');
const {printStatus} = require('./service/utils');
const constants = require('./api/constants');
const config = require('./api/config');
const serviceNames = getServiceNames();

const {sendMessage} = require('./api/send-message');

const rebalanceApi = require('./api/rebalance');

cap
  .version(version)

  .command('start', 'Starts a service')
  .argument('<service>', 'Services', serviceNames)
  .help(`Services: ${serviceNames.join(', ')}`)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      let msg = startService(args.service);
      if (msg) console.log(msg);
    })
  })

  .command('stop', 'Stops a service')
  .argument('<service>', 'Services', serviceNames)
  .help(`Services: ${serviceNames.join(', ')}`)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      stopService(args.service);
    })
  })

  .command('restart', 'Restarts a service')
  .argument('<service>', 'Services', serviceNames)
  .help(`Services: ${serviceNames.join(', ')}`)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      restartService(args.service);
    })
  })

  .command('status', 'Prints service status')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      printStatus();
    })
  })

  .command('rebalance', 'Rebalances the node via circular rebalance.')
  .help('Calls BalanceOfSatoshis in a loop until the target amount is met or all possible routes are exhausted.')
  .argument('<from>', 'From this peer. Can be a partial alias, a pub id, or a bos tag')
  .argument('<to>', 'To this peer. Can be a partial alias, a pub id, or a bos tag')
  .argument('<amount>', 'Amount in sats')
  .option('--ppm <ppm>', 'Max ppm')
  .option('--mins [mins]', 'Max time to run in minutes')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      const amount = (args.amount < 1000) ? args.amount * 1000000 : args.amount;

      rebalanceApi({
        from: args.from,
        to: args.to,
        amount: amount,
        ppm: options.ppm,
        mins: options.mins
      })  
    })
  })

  .command('peers', 'Lists peers classified into inbound, outbound and balanced based on routing history')
  .help('Notable columns: p - % of [inbound or outbound] routing by the peer out of total [inbound or outbound] across all peers; ppm - peer\'s current ppm rate; margin - rebalance ppm margin, rebalance will be profitable as long as its ppm is below this margin.')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      let peers = listPeersFormattedSync();
      console.table(peers.all);
      console.log('inbound peers:');
      console.table(peers.inbound);
      console.log('outbound peers:');
      console.table(peers.outbound);
      console.log('balanced peers:');
      console.table(peers.balanced);
      if (peers.skipped.length > 0) {
        console.log('skipped peers:');
        console.table(peers.skipped);  
      }
    })
  })

  .command('fees', 'Lists peer fees')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      let fees = listFeesSync(lndClient);
      //console.log(classified);
      //console.log(fees);
      let formatted = [];
      fees.forEach(f => {
        let name = f.name;
        formatted.push({
          peer: f.name,
          lc_base: f.local.base,
          lc_rate: f.local.rate,
          rm_base: f.remote.base,
          rm_rate: f.remote.rate
        })
      })
      formatted.sort(function(a, b) {
        return b.rm_rate - a.rm_rate;
      })
      console.table(formatted);
    })
  })

  .command('analyze-fees', 'Analyzes fees')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      const {sendMessage} = require('./api/telegram');
      let classified = classifyPeersSync(lndClient);
      let chans = [];
      classified.outbound.forEach(c => chans.push({chan: c.id, peer: c.peer}));
      let fees = listFeesSync(lndClient, chans);
      let feeMap = {};
      fees.forEach(f => feeMap[f.id] = f);

      const maxPpm = config.rebalancer.maxAutoPpm || constants.rebalancer.maxAutoPpm;
      const buffer = constants.rebalancer.buffer;

      if (classified.outbound.length === 0) return console.log('no outbound peers found');

      // analyze the fees for outbound channels and report on issues
      console.log('analyzing fees for outbound peers');
      let count = 0;
      classified.outbound.forEach(c => {
        let local = Math.round(feeMap[c.peer].local.base/1000 + feeMap[c.peer].local.rate);
        let remote = Math.round(feeMap[c.peer].remote.base/1000 + feeMap[c.peer].remote.rate);

        let xx = Math.floor(local / maxPpm);
        if (xx >= 10) {
          // local fee exceeds max ppm by more than 10x, that's not normal
          // warn the operator so that they are aware and can take corrective
          // action
          console.log(constants.colorRed, '\nURGENT: noticed a potential issue with [outbound]', c.name + '. current fees: local',  feeMap[c.peer].local, 'remote', feeMap[c.peer].remote);
          console.log(constants.colorRed, 'current local fee exceeds the max ppm of ' + maxPpm + ' by more than ' + xx + 'x. this means that rebalances will be significantly more expensive than your set max');
          console.log('revisit your fees ASAP to ensure that you are not draining your liquidity');
          count++;
          return; // skip to the next iteration. the problem is urgent enough to not overload
                  // the operator with extra info
        }
        if (xx >= 2) {
          console.log('\nnoticed a potential issue with [outbound]', c.name + '. current fees: local', feeMap[c.peer].local, 'remote', feeMap[c.peer].remote);
          console.log(constants.colorYellow, 'peer\'s local fee exceeds the max ppm of ' + maxPpm + ' by more than ' + xx + 'x. this means that rebalances will likely be more expensive than your set max');
          console.log('revisit your fees to ensure that you are not draining your liquidity');
          count++;
        }
        if (local < remote + buffer) {
          console.log('\nnoticed an issue with [outbound]', c.name + '. current fees: local',  feeMap[c.peer].local, 'remote', feeMap[c.peer].remote);
          let msg;
          if (local < remote) {
            msg = 'negative rebalance margin of ' + (local - remote) + ' sats. this means that rebalances into this peer are not profitable';
            console.log(constants.colorRed, msg);
          } else {  // remote < local < remote + buffer
            msg = 'not enough of a buffer between local and remote fees: ' + (local - remote) + ' vs ' + buffer + ' recommended. this means that rebalances have less of a chance to go through';
            console.log(constants.colorRed, msg);
          }

          let xx = Math.floor((remote + buffer) / maxPpm);
          if (xx >= 10) {
            msg = 'peer\'s remote fee is too high at the moment, it exceeds your max ppm by more than ' + xx + 'x. consider waiting until the peer adjusts their fees to something more reasonable. in the meantime, rebalances will automatically be placed on hold';
            console.log(constants.colorRed, msg);
            count++;
            return; // skip to the next iteration
          } 
          if (xx >= 2) {
            msg = 'peer\'s remote fee is quite high, it exceeds the max ppm by more than ' + xx + 'x. consider setting peer\'s ppm to ' + (remote + buffer) + ', but proceed with caution. an alternative is to wait until the peer adjusts their fees';
            console.log(msg);
          } else {
            msg = 'to resolve this, consider increasing peer\'s ppm to ' + (remote + buffer);
            console.log(msg);
          }
          count++;
        }
      })
      if (count === 0) console.log('no issues to report');
    })
  })

  .command('htlc-history', 'Prints cumulative htlcs history for peers')
  .argument('[days]', 'Depth of history in days')
  .help('Prints % of total inbound / outbound routing for each peer (e.g. inbound routing from D++ takes 25% of total inbound traffic across all peers), and % of inbound / outbound routing for a peer (e.g. inbound routing from D++ takes 95% of total routing from D++)')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      let days = args.days || 7;  // hardcoded??
      let history = htlcHistoryFormatted(days);
      console.log('htlc history over the past', days, 'days');
      if (history.unknown) {
        console.log('unknown channels:', history.unknown);
      }
      console.log('inbound traffic:');
      console.table(history.inbound);
      console.log('outbound traffic:');
      console.table(history.outbound);
      if (history.noTraffic) {
        console.log('no traffic:');
        console.table(history.noTraffic);
      }
    })
  })

  .command('htlc-analyzer', 'Prints stats about failed htlcs')
  .argument('[days]', 'Depth of history in days')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      let days = args.days || 1;
      let formatted = htlcAnalyzer(days);
      console.log('htlc analysis over the past', days, 'day(s)');
      console.table(formatted);
    })
  })

  .command('rebalance-history', 'Lists past rebalances')
  .argument('[mins]', 'Depth of history in minutes')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      let mins = args.mins || 30;  // hardcoded???
      let secs = (mins > 0) ? mins * 60 : -1;
      let formatted = rebalanceHistoryFormattedSync(secs);
      if (mins > 0) console.log('rebalances over the past', mins, 'minutes');
      console.table(formatted);
    })
  })

  .command('list-peers', 'Lists peer aliases and ids')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      let peers = listPeersSync(lndClient);
      let peerNames = [];
      peers.forEach(p => {
        peerNames.push({
          name: (p.active) ? p.name : '💀 ' + p.name,
          id: p.id,
          active: p.active
        })
      })
      peerNames.sort(function(a, b) {
        return a.name.localeCompare(b.name);
      })
      console.table(peerNames);
    })
  })

  .command('list-channels', 'Lists channels along force closing ones')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      let chans = listChannels();
      if (!chans) return console.log('no channels found, likely due to an error');
      if (chans.active && chans.active.length > 0) {
        console.log('active channels:');
        console.table(chans.active);
      }
      if (chans.pending && chans.pending.length > 0) {
        console.log('forced closing channels:');
        console.table(chans.pending);
      }
    })
  })

  .command('monitor', 'Prints information about ongoing rebalances and stuck htlcs')
  .argument('[secs]', 'Refresh delay in seconds')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      const delay = args.secs || constants.monitor.refresh;  // in seconds
      runMonitorLoop();
      setInterval(runMonitorLoop, delay * 1000);
    })
  })

  .command('send-message', 'Sends a message to a node via keysend')
  .argument('<node>', 'Node pub id')
  .argument('<message>', 'Message to send')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      sendMessage(args.node, args.message);
    })
  })

  .command('update-channel', 'Updates fees on a channel')
  .help('Requires admin.macaroon in api/config.json')
  .argument('<chan>', 'Channel id')
  .option('--base [base]', 'Base fee in msats')
  .option('--ppm [ppm]', 'Ppm in sats per million')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      updateChannelSync(lndClient, {chan: args.chan, base: options.base, ppm: options.ppm});
      console.log('updated');
    })
  })

cap.parse(process.argv);


var channelDbFile;

function runMonitorLoop() {
  const hours = 4;
  console.clear();
  // active rebalances
  console.log(date.format(new Date, 'MM/DD hh:mm:ss'));
  let list = listActiveRebalancesFormattedSync();
  if (list) {
    list.forEach(l => l.amount = withCommas(l.amount));
    list.sort(function(a, b) { return a.from.localeCompare(b.from); });
    console.log('rebalances in progress:');
    console.table(list);
  } else {
    console.log('no active rebalances');
  }

  // rebalance history
  const maxHistoryLines = constants.monitor.rebalanceHistoryLines;
  let history = rebalanceHistoryFormattedSync(hours * 60 * 60).filter(r => r.status === 'success');
  if (history.length > 0) {
    console.log(`\nsuccessful rebalances over the past ${hours} hour(s) (${maxHistoryLines} max lines):`);
    console.table(history.slice(0, maxHistoryLines));
  }

  // pending htlcs
  let htlcs = pendingHtlcsFormattedSync();
  if (htlcs && htlcs.length > 0) {
    console.log('\npending htlcs:');
    console.table(htlcs);
  }

  // forced closed
  let closed = listForcedClosingFormattedSync();
  if (closed && closed.length > 0) {
    console.log('\nforced closing channels:');
    console.table(closed);  
  }

  // channel.db size
  if (!channelDbFile) {
    let cmd = 'find ~ -name channel.db';
    try {
      channelDbFile = execSync(cmd).toString().trim();
    } catch(error) {}
  }
  if (channelDbFile) {
    try {
      let stats = statSync(channelDbFile);
      let size = Math.round(stats.size / Math.pow(10, 6));  // in mbs
      let str = (size >= 1000) ? withCommas(size) + ' gb' : size + ' mb';
      console.log();
      console.log('channel.db size:', str);
      if (size > 5000) {
        console.log(constants.colorRed, 'urgent: channel.db size exceeds 5gb, you must prune ASAP');
        console.log('https://plebnet.wiki/wiki/Compacting_Channel_DB');
      } else if (size > 2000) {
        console.log(constants.colorYellow, 'warning: channel.db size exceeds 2gb, consider pruning');
        console.log('https://plebnet.wiki/wiki/Compacting_Channel_DB');
      }
    } catch(error) {}
  }
}
